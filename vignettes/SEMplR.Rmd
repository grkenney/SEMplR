---
title: "SEMplR Vignette"
output:
  rmarkdown::html_vignette: default
  BiocStyle::html_vignette:
    toc: yes
    toc_float: yes
vignette: >
  %\VignetteIndexEntry{SEMplR Vignette} 
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr_setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.height = 5,
    fig.width = 5
)
options(rmarkdown.html_vignette.check_title = FALSE)
```

```{r load_libraries, message=FALSE}
library(VariantAnnotation)
library(SEMplR)
```


# SNP Effect Matrices

SEMplR uses SNP Effect Matrices (SEMs) to score potential motifs. These are 
matrices contain binding affinity scores and have rows equal to the length of 
the motif and a column for each nucleotide. SEMs are produced by SEMpl, but a 
default set of 223 are included with this package in the `SEMC` data object. 
A full list of the transcription factors included in this default set can be 
found [here](github.com/grkenney/SEMplR/blob/main/vignettes/sempl_metadata.csv) 
or by running `semData(SEMC)`.

The default SEM collection can be loaded with:

```{r load_data}
data(SEMC)
```

Printing the `SNPEffectMatrixCollection`, we can see that we have 223 SEMs and 
13 meta data features for each.
```{r display_data}
SEMC
```

We can access all SEMs in collection the with the function `sems()` or some 
subset of matrices by specifying a vector of semIds in the `semId` parameter.
```{r subset_sem_collection}
getSEMs(SEMC, semId = c("AP2B_HUMAN.SK-N-SH", "ZSCAN4_secondary"))
```

We can view the SEM meta data slot with the `semData` function.
```{r view_sem_metadata}
semData(SEMC)
```

# Scoring Binding

```{r plot_sem}
plotSEM(SEMC,
    motif = "AP2B_HUMAN.SK-N-SH",
    motifSeq = "GCTTTGAGGC", highlight = 1
)
plotSEM(SEMC,
    motif = "AP2B_HUMAN.SK-N-SH",
    motifSeq = "GCTTTCAGGC", highlight = 1, hcol = "red"
)
```

# Scoring Variants

## Prepare inputs

First, we will define the variants we want to score. Variants can be supplied 
to SEMplR as either a `VRanges` or a `GRanges` object. If using `VRanges` 
alleles must be stored in the `ref` and `alt` parameters. If using `GRanges` 
the alleles should be stored in seperate metadata columns. 

Insertions and deletions should be specified by an empty character vector in 
the appropriate allele. 

Optionally, an `id` column can be defined in the object metadata to be used 
as a unique identifier for each variant.

```{r make_vranges}
vr <- VRanges(
    seqnames = c("chr12", "chr19"),
    ranges = c(94136009, 10640062),
    ref = c("G", "T"), alt = c("C", "A"),
    id = c("variant1", "variant2")
)
```

## Scoring

The `scoreVariants` function scores each allele of each variant against every 
SEM provided. From the resulting data object, we can see that we scored 2 
variants, the SEM meta data stored in the object has 13 fields, and we have 
446 rows in the `scores` results table.

There is a row in the `scores` table for each variant/SEM combination. 
Here we scored 2 variants x 223 SEMs to get 446 rows. 
```{r score_variants}
sempl_results <- scoreVariants(
    x = vr,
    sem = SEMC,
    genome = BSgenome.Hsapiens.UCSC.hg38::Hsapiens,
    varId = "id"
)

sempl_results
```
The scoring results has 10 columns:

- **varId**: unique id of the variant as defined in the `id` column of the 
input `GRanges` or `VRanges` object. If not defined, a custom unique identifier 
is generated in the format [seqname]:[range]:[ref_allele]>[alt_allele]

- **semId**: the unique identifier of the SEM

- **refSeq** and **altSeq**: the optimally scored sequence for the reference 
and alternative alleles respectively

- **refScore** and **altScore**: the raw (unnormalized) binding affinity score 
for the reference and alternative alleles respectively

- **refNorm** and **altNorm**: the normalized binding affinity score for the 
reference and alternative alleles respectively

- **refVarIndex** and **altVarIndex**: The position of the frame's starting 
indeces in the scored sequence

There are accessor functions to isolate each slot of the resulting data object:
```{r SEMplScores_accessors}
# access the variants slot
getRanges(sempl_results)

# access the semData slot
semData(sempl_results)

# access the scores slot
scores(sempl_results)
```

## Visualization

```{r plotSemMotifs}
plotSEMMotifs(sempl_results,
    variant = "variant2",
    label = "transcription_factor"
)
```


```{r plotSEMVariants}
plotSEMVariants(sempl_results, sem = "AP2B_HUMAN.SK-N-SH")
```

# Enrichment

```{r caqtl_data, eval=FALSE}
# loading data
caqtl_file <- "caQTL_variants_overlappingPeaks_LD-r2-0.8_withLead.bed"
caqtls <- data.table::fread(file = caqtl_file, sep = "\t")[seq_len(1000), ]
proxy_ID_split <- strsplit(caqtls$proxy_ID, ":")

# formatting position and alleles
chr <- lapply(proxy_ID_split, `[[`, 1) |> unlist()
pos <- lapply(proxy_ID_split, `[[`, 2) |> unlist()
ref_allele <- lapply(proxy_ID_split, `[[`, 3) |> unlist()
alt_allele <- lapply(proxy_ID_split, `[[`, 4) |> unlist()

# building variant annotation obj
vr_e <- VariantAnnotation::VRanges(
    seqnames = chr,
    ranges = pos,
    ref = ref_allele,
    alt = alt_allele
)
data(SEMC)

# score variants
var_scores_e <- scoreVariants(
    vr = vr_e,
    semList = SEMC,
    bs_genome_obj = BSgenome.Hsapiens.UCSC.hg38::Hsapiens
)

plotSEMVariants(var_scores_e, semId = "MA0151.1")
```

```{r enrich_plotSEMMotifs, eval=FALSE}
plotSEMMotifs(var_scores_e, "chr1:906982:C>T", label = "transcription_factor")
```

# Binding Enrichment

Given this is a large set of variants, we might want to check if some 
transcription factors are enriched for binding in one allele or the other.

Here, we will test if any of these transcription factors are bound more than
expected in the reference alleles of this set.

```{r enrich_test, eval=FALSE}
gr_e <- GenomicRanges::GRanges(
    seqnames = chr,
    ranges = pos,
    allele = ref_allele
)

e <- enrichSEMs(
    x = gr_e, semList = SEMC,
    bs_genome_obj = BSgenome.Hsapiens.UCSC.hg38::Hsapiens
)
```

```{r plotEnrich, eval=FALSE}
plt <- plotEnrich(e, semList = SEMC)
plt
```


# Extras

## Loading a custom set of SEMs

First, we create a list of file paths to the .sem files we want to include. 
We will also load the meta data for each sem in a `data.table` object. 
If meta data is used, all SEMs must be represented in the meta data table.

```{r load_custom_sems}
# find .sem files
sem_folder <- system.file("extdata", "SEMs", package = "SEMplR")
sem_files <- list.files(sem_folder, full.names = TRUE)

# load metadata
sempl_metadata_file <- system.file("extdata", "sempl_metadata.csv",
    package = "SEMplR"
)
sempl_metadata <- read.csv(sempl_metadata_file)
```

We will load the matrix and meta data for all SEMs in a single
`SNPEffectMatrixCollection` object. This object has two slots, one containing 
a named list of the matrices and a second slot containing our meta data table 
with a key column connecting the meta data to the names of the matrices.


```{r loadSEMCollection}
sc <- loadSEMCollection(
    semFiles = sem_files,
    semMetaData = sempl_metadata,
    semMetaKey = "SEM"
)
sc
```

```{r session_info}
devtools::session_info()
```

